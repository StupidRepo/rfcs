<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="rfc-0001-webhooks.html"><strong aria-hidden="true">1.</strong> rfc-0001-webhooks</a></li><li class="chapter-item expanded "><a href="rfc-0003-discriminators.html"><strong aria-hidden="true">2.</strong> rfc-0003-discriminators</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rfcs"><a class="header" href="#rfcs">RFCs</a></h1>
<p>RFCs for changes to Revolt. This is a process for adding or changing anything in Revolt, in a formalised and clear manner, so that everyone understands clearly what is needed.</p>
<h2 id="when-you-need-an-rfc"><a class="header" href="#when-you-need-an-rfc">When you need an RFC</a></h2>
<p>You must create an RFC if you intend to make a substantial change to Revolt, or any part of Revolt. This includes:</p>
<ul>
<li>Any new features</li>
<li>Changes to existing ones which have a large impact</li>
<li>Removing features</li>
</ul>
<p>Some things don't need an RFC - these include:</p>
<ul>
<li>Rewording, reorganising or refactoring text or code</li>
<li>Additions which improve the app  in ways which do not add new features  (e.g. performance improvements, bug fixes, better user experience in regards to errors)</li>
<li>Additions which do not affect users of Revolt but only the developers of Revolt</li>
</ul>
<p>If you attempt to open a pull request which would require an RFC without opening an RFC first, your pull request will be closed and you will be asked to submit an RFC before the pull request can be looked at.</p>
<p>If applicable, you're allowed to start working on an implementation for a draft or in-progress RFC - however, if the RFC is denied, your pull request will be denied as well.</p>
<h2 id="before-creating-an-rfc"><a class="header" href="#before-creating-an-rfc">Before creating an RFC</a></h2>
<p>Before submitting an RFC, it's a good idea to discuss your idea first - if your idea is declined, you won't have wasted any time writing an RFC. You can discuss in issues or discussions in Revolt's GitHub organisation or, preferably, <a href="https://rvlt.gg/API">the Revolt API server</a>.</p>
<h2 id="creating-an-rfc"><a class="header" href="#creating-an-rfc">Creating an RFC</a></h2>
<p>To get a feature added to Revolt, you must get your RFC merged into this repository first. At this point, the RFC is &quot;active&quot; and can be discussed.</p>
<ul>
<li><a href="https://github.com/revoltchat/rfcs/fork">Fork the RFC repo</a></li>
<li>Copy the <code>rfc-0000-template.md</code> file into <code>rfcs/rfc-0000-name-of-feature.md</code>. <strong>Don't give it a number yet</strong> - this will be assigned once the RFC is opened.</li>
<li>Fill in the new RFC file. <strong>Make sure to include as much detail as possible</strong> - any ambiguties will slow down the RFC process and will likely need to be corrected.</li>
<li>Submit the RFC. Make sure to give the PR a relevant name - use the RFC's name or something similar which conveys a similar message.</li>
<li>Once the PR is open, you can update the RFC number to match the pull request's number - for example, if the pull request is <code>#36</code>, your RFC will be <code>0036</code>.</li>
<li>The RFC will be labelled by the team.</li>
<li>The RFC will then be discussed and commented on with queries or requests for changes by the team and community members. You can make inline edits to incoporate suggestions - <strong>do not squash or edit existing commits</strong>, as this can lead to confusion.</li>
<li>Once the RFC is close to being finalised, a member of the team will assign the RFC the Final Comment Period label. At this point, the RFC <strong>should not be edited</strong>. This stage will last 10 days; once it ends, the team will be in a position where a final decision on the RFC can be made (i.e. whether to merge it, close it or postpone it). This outcome does not need to match the concensus of all participants of the discussion - however, most (if not all) opinions expressed in the RFC's discussion will be taken into account. During the Final Comment Period, any final comments can be made to lodge any objections before a decision is made.</li>
<li>During the Final Comment Period, if any new substantial arguments or ideas are raised, the team or the RFC's author can cancel then Final Comment Period can be cancelled - the RFC will then go back into development.</li>
</ul>
<h2 id="active-rfc-lifecycle"><a class="header" href="#active-rfc-lifecycle">Active RFC lifecycle</a></h2>
<p>Once the RFC is merged, it will become &quot;active&quot;. You can still make updates to the RFC via pull requests; however, the workflow above must be followed.</p>
<p>Now that it is active, a developer can be assigned to implement the RFC. The author does <strong>not</strong> need to implement it themselves; however, this is the most effective way for the RFC to be implemented. Furthermore, the fact that the RFC is active does not mean it is guaranteed to be implemented or accepted. If, after this stage, it is found that the RFC is no longer deemed necessary or any major flaws are found in it, it can be still denied and closed.</p>
<h2 id="implementing-the-rfc"><a class="header" href="#implementing-the-rfc">Implementing the RFC</a></h2>
<p>Depending on the RFC, an implemention must be made. Once the RFC is merged and active, a tracking issue can be made to track the status of the implemention and link to any currently open pull requests. This can also serve as a discussion area where the implemention or queries about the RFC can be made. If you would like to implement the RFC, comment on the tracking issue so a member of the team can assign you to it. If you are unsure as to whether someone is already working on implementing the RFC, feel free to leave a comment.</p>
<h2 id="rfc-postponement"><a class="header" href="#rfc-postponement">RFC postponement</a></h2>
<p>RFCs can be postponed - if so, they will be labelled with the &quot;postponed&quot; label. This can be for various issues - for example, if the RFC is not being currently worked on, or if it is blocked by other RFCs that are not expected to be finished soon.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: Webhooks</li>
<li>Start Date: 10/03/2023</li>
<li>RFC PR: https://github.com/revoltchat/rfcs/issues/0001</li>
<li>Tracking Issue: https://github.com/revoltchat/revolt/issues/0000</li>
<li>Status: accepted</li>
</ul>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>This RFC adds the ability to be able to send messages from external applications and
services through webhooks, this allows intergration with other services.</p>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>Webhooks make it easy to intergrate with other services, this allows other services
to take advantage of Revolt's to send infomation through revolt. A common example is
GitHub Webhooks which allow you to send messages when a repository changes.</p>
<h1 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h1>
<p>This RFC adds the ability to create, edit, delete webhooks and send messages with the
webhook, webhooks have a name, id, channel id, avatar and token. The token and id are
used to send messages with the webhook.</p>
<p>Fetching the webhook can be done with or without authorization, if you fetch with
authorization the token will be returned, as the token is secret it should not be
given to people without permissions.</p>
<p>There will be a built-in way to use GitHub webhooks from revolt as this is a very
commonly used type of webhook, no other types of webhooks have been considered yet.</p>
<p>Creating a webhook will give it a default name of &quot;Webhook&quot; and default to the first
channel in the channel list, users can then edit the name, channel and avatar.</p>
<h1 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h1>
<p>The database will have an additional document to store the webhooks</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Webhoook {
  // Unique Id
  id: String,

  // The name of the webhook - 1 to 32 chars
  name: String,

  // The avatar of the webhook, if it has one
  avatar: Option&lt;File&gt;,

  // The ID of the channel which this webhook belongs to
  channel: String,

  // The permissions of the webhook
  permissions: u64,

  // The token of the webhook
  token: String
}
<span class="boring">}</span></code></pre></pre>
<p>Addition routes must be added to the API, this includes:</p>
<h2 id="channel-routes"><a class="header" href="#channel-routes">Channel Routes</a></h2>
<pre><code class="language-http">POST /channel/&lt;target&gt;/webhooks - Create webhook in the channel
GET /channel/&lt;target&gt;/webhooks - Gets all webhooks in the channel
</code></pre>
<h2 id="webhook-routes"><a class="header" href="#webhook-routes">Webhook Routes</a></h2>
<pre><code class="language-http">GET /webhooks/&lt;target&gt;/&lt;token&gt; - Gets the webhook with a token, does not require permissions
GET /webhooks/&lt;target&gt; - Gets the wehook, requires permissions
PATCH /webhooks/&lt;target&gt;/&lt;token&gt; - Edits the webhook with a token, does not require permissions
PATCH /webhooks/&lt;target&gt; - Edits the webhooks, requires permissions
DELETE /webhooks/&lt;target&gt;/&lt;token&gt; - Deletes the webhook with a token, does not require permissions
DELETE /webhooks/&lt;target&gt; - Deletes the wehook, requires permissions
POST /webhooks/&lt;target&gt;/&lt;token&gt; - Sends a message with the webhook
POST /webhooks/&lt;target&gt;/&lt;token&gt;/github - GitHub compatible route for sending a message with the webhook
</code></pre>
<p>The PATCH routes take a json body with the data for editing the webhook:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WebhookEditBody {
  // The new name for the webhook
  name: Option&lt;String&gt;,

  // The new avatar for the webhook - Autumn ID
  avatar: Option&lt;String&gt;,

  // The new permissions

  permissions: Option&lt;u64&gt;,

  // The fields to remove
  remove: Option&lt;Vec&lt;RemoveFields&gt;&gt;
}

pub enum RemoveFields {
  Avatar
}
<span class="boring">}</span></code></pre></pre>
<p>The POST routes take the same json body as the message send route. The data the GitHub compatible
route takes can be seen on the <a href="https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads">GitHub docs</a></p>
<p>The message structure must be changed to accommodate these changes, this requires a breaking change
of making <code>Message.author</code> either the user ID or the webhook ID, depending on what sent the message,
when a webhook sends a message a <code>Message.webhook</code> field will contain the webhook's information.</p>
<pre><code class="language-diff">- author: String  // User ID
+ author: String  // Either user ID or webhook ID
+ webhook: Option&lt;MessageWebhook&gt;
</code></pre>
<p>the webhook data inside a message will contain a stripped down version of the <code>Webhook</code> struct to avoid
sending unessessary data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MessageWebhook {
  // The name of the webhook - 1 to 32 chars
  name: String,
  // The id of the avatar of the webhook, if it has one
  avatar: Option&lt;String&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>This will require an update to existing programs which use the API to ensure they do not break
with this change.</p>
<p>Information about the webhook which sent the message is included inside the message, you are also able to
query <code>GET /webhooks/&lt;target&gt;</code> route which returns the same infomation.</p>
<p>There will be three new events to go along side this, these events do not contain the token as these events are
sent to all people who have access to the channel and not just people with permissions</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Events {
  WebhookCreate(Webhook),  // Contains all the info about the webhook which was created

  WebhookUpdate {
    id: String,  // The ID of the updated webhook
    data: PartialWebhook,  // Contains the data which was updated
    remove: Vec&lt;RemoveFields&gt;  // A vec of the fields which where cleared
  },

  WebhookDelete {
    id: String  // The ID of the webhook which was deleted
  },

  // existing events
  ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="permissions"><a class="header" href="#permissions">Permissions</a></h2>
<p>Webhooks are affected by permissions, to for example stop them from uploading files,
webhooks will store the full <code>u64</code> set of permissions to keep consistancy but only
a few permissions will affect the webhook, because of this the client will only show
a select few permissions, this includes:</p>
<ul>
<li>Send Messages</li>
<li>Send Embeds</li>
<li>Masquerade</li>
<li>React - affects interaction reactions</li>
</ul>
<p>When the webhook is created it defaults to having all of these permissions enabled.</p>
<h1 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h1>
<p><a href="https://discord.com">Discord</a> and <a href="https://slack.com">Slack</a> both have webhooks as well both with
similar implementation, both work well and have wide adoption</p>
<h1 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h1>
<p>Currently this RFC includes a breaking change, if possible this would like to be avoided however
no solution has been found yet.</p>
<h1 id="security-concerns"><a class="header" href="#security-concerns">Security concerns</a></h1>
<p>No security concerns have been found yet, however this does allow third-parties to send messages to revolt,
this could be used maliciously however the affected scope is small as it can only send messages.</p>
<h1 id="future-ideas"><a class="header" href="#future-ideas">Future ideas</a></h1>
<p>Currently there is only a Github compatible route for pre-existing formats, in the future this could be
expanded to support more formats such as slack for example.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: Discriminators</li>
<li>Start Date: 06/05/2023</li>
<li>RFC PR: https://github.com/revoltchat/rfcs/pull/3</li>
<li>Tracking Issue: https://github.com/revoltchat/backend/issues/247</li>
<li>Status: accepted</li>
</ul>
<h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<p>Revolt should introduce discriminators which serve as part of a semi-hidden extension to
usernames which allows multiple users to have the same username, the discriminator would
not be visible in most circumstances except when viewing a person's profile and if you
were to add said person by their username.</p>
<h1 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h1>
<p>This RFC aims to move forwards <a href="https://github.com/orgs/revoltchat/discussions/61">prior discussion on the feature suggestions forum</a>,
it stands to solve multiple problems when implemented correctly:</p>
<ul>
<li>
<p>Users should in most, if not all, cases be able to pick their chosen username.</p>
</li>
<li>
<p>This should curb any incentive to sell / steal accounts for &quot;rare usernames&quot;.</p>
<p>Certain &quot;rare&quot; discriminators can also be prohibited.</p>
</li>
<li>
<p>Allow users who do not want to be easily discoverable to stay hidden.</p>
<p>Just a 4-digit discriminator provides 10,000 unique users.
Expanding on this, we could for example, let users hide discriminators in servers and similar privacy features.</p>
</li>
</ul>
<h1 id="guide-level-explanation-1"><a class="header" href="#guide-level-explanation-1">Guide-level explanation</a></h1>
<p>Revolt would be switching to a new username system made up of three parts:</p>
<pre><code>myusername#1234
^ your chosen name (restricted character set)
          ^ separator between chosen name and discriminator
           ^ discriminator (4-digits in range 0001 to 9999)
</code></pre>
<p>Users will also be able to set an optional display name which overrides their username
in various parts of the user interface.</p>
<p>Usernames use a restricted character set of any Unicode alphabet excluding some lookalike
characters from the Cyrillic alphabet, if you username does not currently fit the specification,
then it will be automatically santised upon upgrade and copied to your display name.</p>
<p>Discriminators for new users are generated randomly on sign up while existing users will
get a randomly generated discriminators upon the server software being upgraded.</p>
<blockquote>
<p>Revolt treats usernames as case-insensitive so a full username such as &quot;Jason#1234&quot; is
effectively the same as &quot;jasON#1234&quot; but only &quot;Jason#1234&quot; will display in the UI.</p>
</blockquote>
<p>Users may:</p>
<ul>
<li>
<p>Change the case of their username at any moment, such as from &quot;Jason&quot; to &quot;jasON&quot;.</p>
<p>This will never affect their discriminator.</p>
</li>
<li>
<p>Change their username, but may have their discriminator regenerated if there is a conflict.</p>
<p>Such as if you are changing from &quot;Jason#1234&quot; to &quot;Phil&quot;, but &quot;Phil#1234&quot; is taken.</p>
</li>
</ul>
<h3 id="user-opinion"><a class="header" href="#user-opinion">User Opinion</a></h3>
<p>Prior discussions on the forums primarily seem to lean in favour of discriminators being
implemented into Revolt, the internal team has not raised any complaints against it, and
the primary community on Revolt (&quot;Revolt Lounge&quot;) appears to be somewhat split on the
issue.</p>
<p>As a recent case study, Discord's change to unique usernames only has generated a lot of
backlash and criticism from the community, it appears to be overwhemingly negative but
these experiences are mostly coming from long-term users of Discord. The true opinion of
the average user has not been gauged yet.</p>
<h3 id="usability"><a class="header" href="#usability">Usability</a></h3>
<p>This may make it more difficult to understand how to add users on Revolt, however this
shouldn't be an issue as long as it's clearly communicated through the user interface.
Revolt already allows a wide range of Unicode in usernames so we are definitely not
making a significant UX hit towards the usability of the friend system.</p>
<blockquote>
<p>There are further considerations listed at the end of this document which must be
addressed if this RFC were to be implemented.</p>
</blockquote>
<h1 id="reference-level-explanation-1"><a class="header" href="#reference-level-explanation-1">Reference-level explanation</a></h1>
<p>A new <code>discriminator</code> string field shall be added to the User object, as such the
<code>UNIQUE IGNORE-CASE USERNAME</code> index will be replaced with a
<code>UNIQUE (IGNORE-CASE USERNAME + DISCRIMINATOR)</code> index.</p>
<p>A new <code>display_name</code> string field shall be added to the User object, this will be subject
to all existing username restrictions.</p>
<p>Existing clients may continue to display usernames but will no longer have the guarantee
any one username is unique and must implement the discriminator field to distinguish them
to end users, and they must also show the display name instead of username in the chat
interface and include it in profiles.</p>
<p>Discriminators shall be 4-digit identifiers (this may be expanded in the future if we reach
a point at which they are no longer sustainable, or otherwise at least one username is becoming
saturated).</p>
<p>The friend add route, <code>POST /users/friend</code> will be updated to support parsing a discriminator,
this will provide backwards compatibility for older clients to some limited extent.</p>
<pre><code class="language-json">{
  &quot;username&quot;: &quot;abc#1234&quot;
}
</code></pre>
<h1 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h1>
<p>The main drawbacks are:</p>
<ul>
<li>
<p>Additional information to remember about your username</p>
<p>Although this works both ways in the sense that, you can have a much simpler username.</p>
</li>
<li>
<p>Users may no longer have a completely 'unique' username on the platform</p>
<p>But we're approaching this from the standpoint that usernames on platforms such as these should not have to compete for 'uniqueness'.</p>
</li>
</ul>
<p>I want to take this section to also discuss the case study of Discord's removal of the discriminator system and their <a href="https://discord.com/blog/usernames#heading-3">cited drawbacks</a>,
it is worth noting however that Discord has not really specified how they've generated these statistics or this information,
although for the sake of the following they are taken at face value:</p>
<ul>
<li>
<blockquote>
<p>More than 40% of you either don’t remember your discriminator or don’t even know what a discriminator is. That’s a big problem when discriminators are required to add a new friend.</p>
</blockquote>
<p>This RFC cannot address this issue however further work can be done to ease these interactions:</p>
<ul>
<li>
<p>R&amp;D to determine how to build the UI to intuitively tell the user how to share their username with their discriminator</p>
</li>
<li>
<p>Implementation of friend links / codes to ease connecting users to each other</p>
<p>This is not something that Discord has solved and to this day there is no way to create a friend request link.</p>
</li>
<li>
<p>Implementation of nearby find (prior art: Discord) / QR friend codes (prior art: Snapchat) / add by contact book (prior art: Signal, WhatsApp)</p>
<p>These may help streamline IRL interactions by providing users with a simple flow to follow.</p>
</li>
<li>
<p>Implementation of add by connections</p>
<p>Allow adding other people by common social media connections.</p>
</li>
<li>
<p>Global user search (prior art: Steam)</p>
<p>Allow users to opt-in to a global username search / or otherwise also search through mutual members on servers, to avoid needing the discriminator altogether.</p>
</li>
</ul>
</li>
<li>
<blockquote>
<p>Across Discord, almost half of all friend requests fail to connect the user with the person they wanted to match with, mostly because users enter an incorrect or invalid username due to a combination of missing discriminator and incorrect casing.</p>
</blockquote>
<ul>
<li>
<p>Issues with ease of adding are addressed in the point above, however incorrect casing is irrelevant to Revolt as-is because Revolt's usernames are already case-insensitive and this will not change.</p>
<p>If we look at the given example:</p>
<blockquote>
<p>You meet someone IRL that you want to talk to on Discord, and they say “I’m Phibi Eight Nine Three Six!” You go home and add “phibi#8936” only to find out you added the wrong “Phibi” because your new friend’s username is actually “PhIBI#8936”.</p>
</blockquote>
<p>Revolt does not permit a registration of both &quot;PhIBI&quot; and &quot;phibi&quot;.</p>
</li>
</ul>
</li>
<li>
<blockquote>
<p>You want to use a common name like “Mike” or “Jane” but there are already 9,999 Mikes or Janes so you’re blocked from that name altogether.</p>
</blockquote>
<p>We are not restricted to just 4-digit discriminators in our implementation.</p>
</li>
<li>
<blockquote>
<p>You like to change your username a lot and get rate limited.</p>
</blockquote>
<p>If we were also to add more stringent rate limits, this may be solved by also including display names.</p>
</li>
<li>
<blockquote>
<p>Your friend says they changed their name to “vernacular” but actually it’s “𝖛𝖊𝖗𝖓𝖆𝖈𝖚𝖑𝖆𝖗” and you have trouble finding them.</p>
</blockquote>
<p>While this is a valid concern, I would personally put this down as the user's own issue.</p>
</li>
</ul>
<h1 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h1>
<p>Discriminators (with display names and a restricted character set) appear to show the least disadvantages out of all of the solutions discussed so far.</p>
<div class="table-wrapper"><table><thead><tr><th>Solution</th><th>Description</th><th style="text-align: center">Users have desired username</th><th style="text-align: center">Selling disincentivized</th><th style="text-align: center">Privacy</th><th style="text-align: center">Usability</th><th style="text-align: center">Difficulty</th></tr></thead><tbody>
<tr><td><strong>Discriminators</strong></td><td>Proposed in this RFC</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">⚠️</td><td style="text-align: center">Low</td></tr>
<tr><td><strong>Discriminators</strong><br/>w/ display names</td><td>Show display names with greater priority to username / discriminator combinations.<br/>* May be proposed in this RFC</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">⚠️</td><td style="text-align: center">Low</td></tr>
<tr><td><strong>Discriminators</strong><br/>w/ display names<br/>w/ restricted character set</td><td>Also restrict the characters that you can use in the username itself.<br/>* May be proposed in this RFC</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">Medium †</td></tr>
<tr><td>Unique usernames</td><td>Current system on Revolt<br/>(but any unicode username is allowed)</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">⚠️</td><td style="text-align: center">Low</td></tr>
<tr><td>Unique usernames<br/>w/ restricted character set</td><td>Alphanumeric unique global usernames</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">Medium †</td></tr>
<tr><td>Unique usernames<br/>w/ display names</td><td>Either unique username solution but with added display names that show instead of the username</td><td style="text-align: center">⚠️</td><td style="text-align: center">❌</td><td style="text-align: center">⚠️</td><td style="text-align: center">✅</td><td style="text-align: center">Low</td></tr>
<tr><td>Remove usernames altogether<br/>(only display names)</td><td>Resort to using friend codes, invite links, and the like exclusively.</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">⚠️</td><td style="text-align: center">High ¶</td></tr>
<tr><td>Unique cryptographic user identifiers with display names</td><td>Resort to using friend codes, invite links, and the like exclusively.</td><td style="text-align: center">⚠️</td><td style="text-align: center">✅</td><td style="text-align: center">⚠️</td><td style="text-align: center">⚠️</td><td style="text-align: center">Medium</td></tr>
</tbody></table>
</div>
<p>In regards to this table,</p>
<ul>
<li>Privacy means whether users can avoid being discovered based on their common names.</li>
<li>Usability is whether users can practically and quickly add each other.</li>
<li>† Restricting existing usernames further would potentially require some users to change username.</li>
<li>¶ Removing usernames altogether would require a complete redesign of how friends work on Revolt.</li>
</ul>
<p>Discriminators also help solve a couple of issues with regards to username abandonment, users may sign up and:</p>
<ol>
<li>Forget their account credentials or otherwise get locked out, and never recover their account.</li>
<li>Forget that their account even exists.</li>
<li>Decide they don't want to keep using their account but never delete it.</li>
</ol>
<p>Revolt does not currently automatically delete old accounts with no activity which is why this poses an issue.</p>
<p>Given Revolt's current size, 4-digit numeric discriminators currently pose the least issues.</p>
<div class="table-wrapper"><table><thead><tr><th>Solution</th><th style="text-align: center">Example</th><th>Description</th><th style="text-align: center">Usability</th><th style="text-align: center">Quantity</th><th style="text-align: center">Safe</th></tr></thead><tbody>
<tr><td>4-digit</td><td style="text-align: center"><code>#1234</code></td><td>Any 4 digits</td><td style="text-align: center">✅</td><td style="text-align: center">Low</td><td style="text-align: center">✅</td></tr>
<tr><td>N-digit</td><td style="text-align: center"><code>#123456</code></td><td>Any N digits</td><td style="text-align: center">⚠️</td><td style="text-align: center">Medium</td><td style="text-align: center">⚠️</td></tr>
<tr><td>Variable Digit</td><td style="text-align: center"><code>#123</code> ... <code>#1234</code></td><td>Scale between n and N digits depending on use</td><td style="text-align: center">⚠️</td><td style="text-align: center">Infinite</td><td style="text-align: center">⚠️</td></tr>
<tr><td>4-hex</td><td style="text-align: center"><code>#12AF</code></td><td>Any 4 hex characters</td><td style="text-align: center">✅</td><td style="text-align: center">Medium</td><td style="text-align: center">⚠️</td></tr>
<tr><td>4-char</td><td style="text-align: center"><code>#1ABZ</code></td><td>Any 4 alphanumeric characters</td><td style="text-align: center">❌ †</td><td style="text-align: center">High</td><td style="text-align: center">❌</td></tr>
</tbody></table>
</div>
<p>In regards to this table:</p>
<ul>
<li>Usability is whether the solution is practical, i.e. reasonably sized and simple.</li>
<li>Quantity is how many possible discriminators may be housed under one username.</li>
<li>Safe is whether the solution is not susceptible to generating undesired combinations and phrases.</li>
<li>† Allowing any alphanumeric characters may cause confusion between similar charactres using certain fonts, e.g. <code>O</code> and <code>0</code>.</li>
</ul>
<p>We also choose to restrict usernames to any Unicode alphabet rather than the full range given this has the best compromise between reasonable usernames, users affected, and localisation:</p>
<div class="table-wrapper"><table><thead><tr><th>Permissible Format</th><th style="text-align: center">Regex</th><th style="text-align: center">Users affected by change</th><th style="text-align: center">Supports regional dialects</th><th>Potential for abuse</th></tr></thead><tbody>
<tr><td>Alphanumeric</td><td style="text-align: center"><code>^[a-zA-Z\d]+$</code></td><td style="text-align: center">18%</td><td style="text-align: center">❌</td><td>Low</td></tr>
<tr><td>Any alphabet ¶ or digit</td><td style="text-align: center"><code>^(\p{L} \| \d)+$</code></td><td style="text-align: center">17%</td><td style="text-align: center">✅</td><td>Medium ¶</td></tr>
<tr><td>Alphanumeric with special characters †</td><td style="text-align: center"><code>^([a-zA-Z\d_.-])+$</code></td><td style="text-align: center">11%</td><td style="text-align: center">❌</td><td>Low</td></tr>
<tr><td>Any alphabet ¶ or digit with special characters †</td><td style="text-align: center"><code>^(\p{L} \| [\d_.-])+$</code></td><td style="text-align: center">9%</td><td style="text-align: center">✅</td><td>Medium ¶</td></tr>
<tr><td>Current format</td><td style="text-align: center"><code>^[^\u200BА-Яа-яΑ-Ωα-ω@#:\n\r\[\]]+$</code></td><td style="text-align: center">0%</td><td style="text-align: center">✅</td><td>High</td></tr>
</tbody></table>
</div>
<ul>
<li>† Special characters include underscore, period and dash.</li>
<li>¶ Certain lookalike characters will continue to be blocked, such as those from the cyrillic alphabet.</li>
</ul>
<h1 id="prior-art-1"><a class="header" href="#prior-art-1">Prior art</a></h1>
<p>This has been implemented before on other platforms:</p>
<ul>
<li>Discord's discriminator system</li>
<li>Blizzard's <a href="https://us.battle.net/support/en/article/75767">BattleTag system</a></li>
</ul>
<h1 id="unresolved-questions-1"><a class="header" href="#unresolved-questions-1">Unresolved questions</a></h1>
<p>No currently unresolved questions.</p>
<h1 id="security-concerns-1"><a class="header" href="#security-concerns-1">Security concerns</a></h1>
<p>This should not impact security, since this is almost entirely a cosmetic change to usernames.</p>
<p>This should not have any adverse effects for functionality such as blocking users as this is entirely handled using internal IDs.</p>
<h1 id="future-ideas-1"><a class="header" href="#future-ideas-1">Future ideas</a></h1>
<p>As discussed previously, we may look into implementing:</p>
<ul>
<li>Friend links / codes</li>
<li>Nearby find / QR friend codes / add by contact book</li>
<li>Add users by social connections</li>
<li>Global user search</li>
<li>Better friend flow UX</li>
</ul>
<p>We may also want to look into implementing additional privacy settings for adding users.</p>
<p>As per <a href="https://github.com/revoltchat/rfcs/pull/3#discussion_r1199818589">discussion comment</a>, we may want to warn users that
their username contains weird unicode or other characters that may look similar or weird, that may prevent them from adding
other people on the platform.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
